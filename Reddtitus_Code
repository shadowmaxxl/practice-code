import tkinter as tk
from tkinter import filedialog
from tkinter import messagebox
import webbrowser
from tkinter import PhotoImage
from tkinter import simpledialog
import customtkinter as ctk
import re
import shutil
from tkinter import colorchooser
from customtkinter.windows.ctk_tk import CTk
from customtkinter.windows.widgets.core_rendering.ctk_canvas import CTkCanvas  # Import regular expression import tkinter as tk
from PIL import Image, ImageTk
from tkinter import filedialog
from tkinter import ttk
import os
import subprocess

count = 1.0


class SyntaxHighlighter(ctk.CTkTextbox):

  def __init__(self, master=None, **kwargs):
    super().__init__(master, **kwargs)
    self.syntax = self

    # Define keywords for your language (modify as needed)
    self.keywords = [
        "function",
        "return",
        "if",
        "else",
        "while",
        "for",
        "do",
        "break",
        "continue",
        "#using",
        "#insert",
        "#define",
        "notify",
        "thread",
        "waittill",
        "continue",
        "wait",
    ]
    self.keywords2 = [
        "#precache", "REGISTER_SYSTEM_EX", "undefined", "bool", "list", "dict",
        "tuple", "set", "None"
    ]
    self.variables = ["self", "level"]
    self.configure(fg_color="#262335", text_color="white")
    # Bind to the KeyRelease event to trigger syntax highlighting
    self.bind("<KeyRelease>", self.on_text_change)

    print("SyntaxHighlighter initialized.")

  def on_text_change(self, event):
    """Triggered when a key is released, updates syntax highlighting"""
    if event.keysym in {"space", "Return"} or not event.keysym.isalpha(
    ):  # Update on spacebar or non-letter key press
      text = self.get(1.0, tk.END)[:-1]  # Get text (remove trailing newline)
      self.apply_syntax_highlighting(text)

    # Adjust indentation when user presses 'Return' (Enter) key
    if event.keysym in {"Return"}:
      print("return detected")
      cursor_pos = self.index("insert")  # Get current cursor position
      print(cursor_pos)
      text_before_cursor = self.get(1.0,
                                    cursor_pos)  # Get text before the cursor
      print(text_before_cursor)
      line_start = text_before_cursor.rfind(
          "\n")  # Find the start of the current line
      current_line = text_before_cursor[line_start +
                                        1:]  # Get the current line
      print(current_line)
      print(current_line)
      # Get the line number from the cursor position
      line_number = int(
          cursor_pos.split('.')[0])  # Convert the line number to an integer
      print(line_number)
      # Get the previous line's text
      previous_line = self.get(f"{line_number - 1}.0", f"{line_number}.0")
      print(previous_line)
      # Get the indentation of the previous line
      indent = self.get_indent_of_line(
          previous_line)  # Get the indentation of the previous line

      # Insert the new line with proper indentation
      self.insert(cursor_pos, indent)  # Insert the new line with proper indent

      # Move the cursor to the correct position (right after the inserted indentation)
      self.mark_set("insert", f"{cursor_pos.split('.')[0]}.{len(indent)}")

  def get_indent_of_line(self, line):
    """Returns the indentation of a given line (i.e., spaces or tabs)."""
    indent = ""
    for char in line:
      if char == " " or char == "\t":  # Check for space or tab characters
        indent += char
      else:
        break  # Stop once we encounter a non-indentation character
    return indent

  def apply_syntax_highlighting(self, text):
    """Applies syntax highlighting to the entire text"""
    print("Syntax highlighting starting")
    # First, remove all previous tags
    for tag in ("string", "keyword", "comment", "variable", "red"):
      self.tag_remove(tag, "1.0", tk.END)
    self._highlight_brackets(text)

    # Apply highlighting in correct order - most specific to least specific
    # Variables and keywords should be highlighted first as they might appear within strings/comments
    self._highlight_variables(text)
    self._highlight_keywords(text)
    self._highlight_red(text)  # Including numbers, capitalized words, etc.

    # Strings and comments should be highlighted last to override other highlighting
    self._highlight_strings(text)
    self._highlight_comments(text)

  def _highlight_keywords(self, text):
    """Highlights keywords in the text"""
    for keyword in self.keywords:
      pattern = r'(?<!\w)#?' + re.escape(keyword) + r'(?!\w)'
      matches = re.finditer(pattern, text)
      for match in matches:
        print(match)
        start_pos = self.index(f"1.0 + {match.start()} chars")
        end_pos = self.index(f"1.0 + {match.end()} chars")
        # Apply tag without deleting the content
        self.tag_add("keyword", start_pos, end_pos)

  def _highlight_strings(self, text):
    """Highlights string literals in the text"""
    # Handle single and double quoted strings separately to avoid nested quote issues
    patterns = [
        r'(?<!\\)"(?:\\.|[^"\\])*"',  # Double quoted strings
        r"(?<!\\)'(?:\\.|[^'\\])*'"  # Single quoted strings
    ]

    for pattern in patterns:
      matches = re.finditer(pattern, text)
      for match in matches:
        start_pos = self.index(f"1.0 + {match.start()} chars")
        end_pos = self.index(f"1.0 + {match.end()} chars")
        # Remove any existing tags in this range first
        for tag in ("keyword", "variable", "red"):
          self.tag_remove(tag, start_pos, end_pos)
        # Apply string tag
        self.tag_add("string", start_pos, end_pos)

  def _highlight_comments(self, text):
    """Highlights comments in the text"""
    comment_pattern = r"//[^\n]*"  # Match comments until end of line
    matches = re.finditer(comment_pattern, text)
    for match in matches:
      start_pos = self.index(f"1.0 + {match.start()} chars")
      end_pos = self.index(f"1.0 + {match.end()} chars")
      # Remove any existing tags in this range first
      for tag in ("keyword", "variable", "string", "red"):
        self.tag_remove(tag, start_pos, end_pos)
      # Apply comment tag
      self.tag_add("comment", start_pos, end_pos)

  def _highlight_variables(self, text):
    """Highlights variables in the text"""
    for variable in self.variables:
      pattern = r'(?<!\w)#?' + re.escape(variable) + r'(?!\w)'
      matches = re.finditer(pattern, text)
      for match in matches:
        start_pos = self.index(f"1.0 + {match.start()} chars")
        end_pos = self.index(f"1.0 + {match.end()} chars")
        # Check if it's inside a string or a comment
        if not any(
            self.tag_ranges(tag) for tag in ("string", "comment") if start_pos
            in self.tag_ranges(tag) and end_pos in self.tag_ranges(tag)):
          self.tag_add("variable", start_pos, end_pos)

  def _highlight_red(self, text):
    """Highlights red in the text"""
    self._highlight_keywords2(text)
    self._highlight_numbers(text)
    self._highlight_capitalized(text)

  def _highlight_keywords2(self, text):
    """Highlights keywords2 in the text"""
    for keyword2 in self.keywords2:
      pattern = r'(?<!\w)#?' + re.escape(keyword2) + r'(?!\w)'
      matches = re.finditer(pattern, text)
      for match in matches:
        start_pos = self.index(f"1.0 + {match.start()} chars")
        end_pos = self.index(f"1.0 + {match.end()} chars")
        # Check if it's inside a string or a comment
        print(f"Keyword: {keyword2}")
        print(f"Start: {start_pos}, End: {end_pos}")
        if not any(
            self.tag_ranges(tag) for tag in ("string", "comment") if start_pos
            in self.tag_ranges(tag) and end_pos in self.tag_ranges(tag)):
          self.tag_add("red", start_pos, end_pos)

  def _highlight_numbers(self, text):
    """Highlights numbers in the text"""
    number_pattern = r'\b\d+\b'
    matches = re.finditer(number_pattern, text)
    for match in matches:
      start_pos = self.index(f"1.0 + {match.start()} chars")
      end_pos = self.index(f"1.0 + {match.end()} chars")
      # Check if it's inside a string or a comment
      if not any(
          self.tag_ranges(tag)
          for tag in ("string", "comment") if start_pos in self.tag_ranges(tag)
          and end_pos in self.tag_ranges(tag)):
        self.tag_add("red", start_pos, end_pos)
        print(f"Number: {match.group()}")
        print(f"Start: {start_pos}, End: {end_pos}")

  def _highlight_capitalized(self, text):
    """Highlights capitalized words in the text"""
    capitalized_pattern = r'\b[A-Z]+(?:_[A-Z]+)*\b'
    matches = re.finditer(capitalized_pattern, text)
    for match in matches:
      start_pos = self.index(f"1.0 + {match.start()} chars")
      end_pos = self.index(f"1.0 + {match.end()} chars")
      if not any(
          self.tag_ranges(tag)
          for tag in ("string", "comment") if start_pos in self.tag_ranges(tag)
          and end_pos in self.tag_ranges(tag)):
        self.tag_add("red", start_pos, end_pos)
        # Check if it's inside a string or a comment
        print(f"Capitalized: {match.group()}")
        print(f"Start: {start_pos}, End: {end_pos}")

  def _highlight_brackets(self, text):
    """Highlights matching brackets in random colors and unmatched brackets in red"""
    # Dictionary to store bracket pairs
    brackets = {'(': ')', '[': ']', '{': '}'}

    # Stack to keep track of opening brackets
    stack = []
    # Dictionary to store positions of brackets
    positions = {}
    # List to store unmatched brackets
    unmatched = []

    # First pass: find all bracket positions and match them
    for i, char in enumerate(text):
      pos = f"1.0 + {i} chars"

      if char in brackets.keys():  # Opening bracket
        stack.append((char, pos))
      elif char in brackets.values():  # Closing bracket
        if not stack:  # No opening bracket to match with
          unmatched.append(pos)
        else:
          opening_char, opening_pos = stack[-1]
          if char == brackets[opening_char]:  # Matching pair
            positions[opening_pos] = (pos, opening_char + char)
            stack.pop()
          else:  # Wrong type of closing bracket
            unmatched.append(pos)

    # Add remaining opening brackets to unmatched
    for _, pos in stack:
      unmatched.append(pos)

    # Remove any existing bracket highlighting
    self.tag_remove("unmatched_bracket", "1.0", tk.END)
    for i in range(1, 11):  # Assuming max 10 different colors
      self.tag_remove(f"bracket_pair_{i}", "1.0", tk.END)

    # Color list for matching pairs (excluding red which is for unmatched)
    colors = [
        '#86ff7c', '#fffd6f', '#87CEFA', '#ff75ff', '#54c9ff', '#ff756f',
        '#ff6f98', '#ff8f00', '#ff00f0', '#89c422'
    ]

    # Highlight matching pairs
    for i, (opening_pos, (closing_pos, pair)) in enumerate(positions.items()):
      color = colors[i % len(colors)]  # Cycle through colors
      tag_name = f"bracket_pair_{i+1}"

      # Configure the tag with the random color
      self.tag_config(tag_name, foreground=color)

      # Apply highlighting to the pair
      self.tag_add(tag_name, opening_pos)
      self.tag_add(tag_name, closing_pos)

    # Highlight unmatched brackets in red
    self.tag_config("unmatched_bracket", foreground="red")
    for pos in unmatched:
      self.tag_add("unmatched_bracket", pos)

  def _configure_bracket_tags(self):
    """Configure the tags for bracket highlighting"""
    # Configure tag for unmatched brackets
    self.tag_config("unmatched_bracket", foreground="#ff0000")

    # Configure tags for matched pairs
    colors = [
        '#FFB6C1', '#98FB98', '#87CEFA', '#DDA0DD', '#F0E68C', '#E6E6FA',
        '#FFE4C4', '#98FF98', '#B0E0E6', '#FFA07A'
    ]

    for i, color in enumerate(colors, 1):
      self.tag_config(f"bracket_pair_{i}", foreground=color)

  def tag_configure(self, tag, foreground):
    """Set the tag color for syntax highlighting"""
    self.tag_add(tag, "1.0", "end")  # Apply tag to the entire content
    self.tag_config(tag, foreground=foreground)


class TextLineNumbers(ctk.CTkCanvas):
  ctk.set_appearance_mode("dark")

  def __init__(self, *args, **kwargs):
    super().__init__(*args,
                     **kwargs,
                     highlightthickness=0,
                     background="#281c2c")
    self.textwidget = None
    self.line_number_font = ("Verdana", 9)  # Font for line numbers
    self.line_number_color = "lightgrey"  # Color for line numbers
    self.line_number_bold = True

  def attach(self, text_widget):
    """Attach the Text widget to the line numbers canvas."""
    self.textwidget = text_widget

  def redraw(self, event=None, color="lightgrey", *args):
    """Redraw the line numbers on the canvas."""
    if color.startswith("<"):
      return

    self.delete("all")  # Clear the canvas before redrawing

    if count == 2.5:
      self.line_number_font = ("Verdana", int(count * 7))
    elif count >= 2.0:
      self.line_number_font = ("Verdana", int(count * 8))
    elif count > 1.5:
      self.line_number_font = ("Verdana", int(count * 9))
    else:
      self.line_number_font = ("Verdana", int(count * 10))

    i = self.textwidget.index(
        "@0,0")  # Get the index of the first visible character
    while True:
      dline = self.textwidget.dlineinfo(
          i)  # Get the information about the line
      if dline is None:
        break  # Stop if no more lines
      y = dline[1] + 3  # Get the vertical position of the line
      linenum = str(i).split(".")[0]  # Extract the line number from the index

      xoffset = 0
      yoffset = 0
      if count == 2.5:
        xoffset = 1
        yoffset = 7
      elif count == 2.0:
        xoffset = 1
        yoffset = 4
      elif count > 1.5:
        xoffset = 1
        yoffset = 1
      elif count < 1:
        xoffset = 0
        yoffset = -1.5

      self.create_text(20 + xoffset,
                       y + 1 + yoffset,
                       anchor="n",
                       text=linenum,
                       fill=color,
                       font=self.line_number_font)

      i = self.textwidget.index(f"{i}+1line")  # Move to the next line

  def on_click(self, event):
    """Triggered when the user clicks on a line number."""
    # Get the index of the position where the click happened
    line_index = self.textwidget.index(
        "@%s,%s" % (event.x, event.y))  # Get the index based on mouse position
    line_number = line_index.split(".")[0]  # Extract the line number

    # If Ctrl is held, add to the selection; otherwise, clear the selection
    if event.state & 0x4:  # Check if the Ctrl key is held
      self.add_to_selection(line_number)
    else:
      self.select_line(line_number)

  def select_line(self, line_number):
    """Select the entire line in the Text widget."""
    start_index = f"{line_number}.0"
    end_index = f"{line_number}.end"

    # Clear previous selection (if any) and select the new line
    self.textwidget.tag_remove("sel", "1.0",
                               "end")  # Remove previous selection
    self.textwidget.tag_add("sel", start_index,
                            end_index)  # Add selection range
    self.textwidget.mark_set(
        tk.INSERT, start_index)  # Move the cursor to the start of the line
    self.textwidget.see(
        start_index)  # Scroll to make sure the selected line is visible

  def add_to_selection(self, line_number):
    """Add the clicked line to the current selection."""
    start_index = f"{line_number}.0"
    end_index = f"{line_number}.end"

    # Add the clicked line to the selection without removing the previous ones
    self.textwidget.tag_add("sel", start_index, end_index)
    self.textwidget.see(
        start_index)  # Scroll to make sure the selected line is visible


class ScrollText(tk.Frame):

  def __init__(self, master, *args, **kwargs):
    super().__init__(master, *args, **kwargs)

    # Create the Text widget (CTkTextbox)
    self.text = SyntaxHighlighter(self, width=400, corner_radius=0, undo=True)
    self.text.configure(tabs=18)
    #
    self.text.bind("<Control-a>", self.selectall)
    # Configure the tags for keywords, strings, and comments
    self.text.tag_configure("keyword",
                            foreground="#fede5d")  # Keyword color blue
    self.text.tag_configure("string",
                            foreground="#ff7e36")  # String color green
    self.text.tag_configure("comment", foreground="gray")  # Comment color gray
    self.text.tag_configure("variable",
                            foreground="#a079f0")  # Variable color purple
    self.text.tag_configure("red", foreground="#ff6853")  # Red color red
    # Line number canvas (for line numbers)
    self.numberLines = TextLineNumbers(self, width=40, bg='#313335')
    self.numberLines.attach(self.text)

    # Using grid() instead of pack() for both line numbers and text widget
    self.numberLines.grid(row=0, column=0,
                          sticky="ns")  # Line numbers on the left
    self.text.grid(row=0, column=1,
                   sticky="nsew")  # Text widget fills remaining space

    # Ensure the row and column configurations allow proper resizing
    self.grid_rowconfigure(
        0, weight=1)  # Make the row with the text widget expand vertically
    self.grid_columnconfigure(
        0, weight=0)  # Line numbers don't need to stretch horizontally
    self.grid_columnconfigure(
        1, weight=1)  # Text widget should expand horizontally and vertically

    # Event binding for text widget (keypress, etc.)
    self.text.bind(
        "<KeyRelease>",
        self.onPressDelay)  # Trigger syntax highlighting on key release
    self.text.bind("<Button-1>", self.numberLines.redraw)
    self.text.bind("<MouseWheel>", self.onPressDelay)

    # Bind the <KeyPress> event to handle automatic insertion of '}'
    self.text.bind("<KeyPress>", self.handle_brace)

    # Bind the click event on the number lines
    self.numberLines.bind("<Button-1>", self.numberLines.on_click)

  def handle_brace(self, event):
    """Handle automatic insertion of closing brace with proper indentation."""
    # Get the current line and its content
    line_number = self.text.index(tk.INSERT).split('.')[0]
    line_start = f"{line_number}.0"
    line_content = self.text.get(line_start, f"{line_number}.end")

    # If '{' is typed
    if event.char == '{':
      # Count leading spaces/tabs in current line
      indent = len(line_content) - len(line_content.lstrip())
      indent_str = line_content[:
                                indent]  # Preserve exact indent characters (tabs or spaces)

      # Insert the braces and newlines with proper indentation
      self.text.insert(tk.INSERT, '{\n')
      self.text.insert(tk.INSERT,
                       indent_str + '\t\n')  # Indent + tab for content
      self.text.insert(tk.INSERT,
                       indent_str + '}')  # Same indent as opening brace

      # Move cursor up and to the end of the indented line
      self.move_cursor_up_and_to_end()
      return "break"

  def move_cursor_up_and_to_end(self):
    """Move cursor up one line and to the end of indented position."""
    current_position = self.text.index(tk.INSERT)
    line_number, _ = current_position.split('.')

    # Move to previous line
    previous_line = str(int(line_number) - 1)
    # Move to end of content on that line
    target_position = f"{previous_line}.end"

    self.text.mark_set(tk.INSERT, target_position)
    self.text.see(target_position)

  def onPressDelay(self, *args):
    """ Delay the redrawing of the line numbers. """
    self.after(2, self.numberLines.redraw)

  def get(self, *args, **kwargs):
    return self.text.get(*args, **kwargs)

  def insert(self, *args, **kwargs):
    return self.text.insert(*args, **kwargs)

  def delete(self, *args, **kwargs):
    return self.text.delete(*args, **kwargs)

  def index(self, *args, **kwargs):
    return self.text.index(*args, **kwargs)

  def redo(self, *args, **kwargs):
    return self.text.edit_redo(*args, **kwargs)

  def selectall(self, event=None):
    self.text.tag_add('sel', '1.0', 'end')
    self.text.mark_set(tk.INSERT, 'end')
    self.text.see(tk.INSERT)
    return 'break'

  def redraw(self):
    self.numberLines.redraw()

  def __sync_scrollbar_with_text(self, *args):
    """
        Custom synchronization between the scrollbar and the Text widget.
        It handles the scrolling in a way that updates the scrollbar thumb position.
        """
    self.text.yview(*args)  # Update the Text widget's view.


class TextEditor:

  def __init__(self, master):
    self.master = master
    master.title("GSCEditor")
    self.active_menus = []
    self.workingpath = os.path.expanduser("~/SkeletalSociableCores")
    self.selected_colors = {
        "frame1": "#262335",
        "frame2": "#281c2c",
        "frame3": "#ffffff"
    }

    # Create the toolbar frame to hold both the logo and the menu bar
    self.toolbar_frame = ctk.CTkFrame(master, bg_color="black", border_width=0)
    self.toolbar_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)

    # Menu Bar
    code = "file_code"
    menubar = tk.Menu(
        master,
        fg="white",
        bg="#281c2c",
        bd=0,
        relief="flat",
        #activebackground='darkgrey',
        activeborderwidth=3,
        font=("Verdana", 12))
    self.master.bind("<Button-1>", self.close_all_active_menus_on_click)
    self.menubar = menubar
    # Open and resize the image
    #image_path = "logo_main.png"  # Replace with your image path
   # image = Image.open(image_path)
    #resized_image = image.resize((22, 22))  # Resize to 20x20

    # Convert the resized image to a PhotoImage
    #open_image = ImageTk.PhotoImage(resized_image)

    # Attach the image to the menubar
    #menubar.open_image = open_image  # Store a reference to avoid garbage collection
   # menubar.add_command(image=open_image,
   #                     label="",
   #                     command=self.toggle_sidebar)
    self.master.bind("<Control-b>", self.toggle_sidebar)

    filemenu = tk.Menu(menubar,
                       tearoff=0,
                       fg="white",
                       bg="#281c2c",
                       bd=0,
                       relief="flat",
                       font=("Verdana, 12"))
    filemenu.add_command(label="New", command=self.new_file)
    filemenu.add_command(label="Open", command=self.open_file)
    filemenu.add_command(label="Save", command=self.save_file)
    filemenu.add_command(label="Save As", command=self.save_as_file)
    filemenu.add_separator()
    filemenu.add_command(label="Exit", command=master.quit)
    filemenu.bind("<Enter>",
                  lambda event: self.on_menu_select(event, filemenu))
    self.filemenu = filemenu
    menubar.add_cascade(label="File", menu=filemenu)

    code = "edit_code"
    editmenu = tk.Menu(menubar,
                       tearoff=0,
                       fg="white",
                       bg="#281c2c",
                       bd=0,
                       relief="flat",
                       font=("Verdana, 12"))
    editmenu.add_command(label="Undo", command=self.undo)
    editmenu.add_command(label="Redo", command=self.redo)
    editmenu.add_separator()
    editmenu.add_command(label="Cut", command=self.cut)
    editmenu.add_command(label="Copy", command=self.copy)
    editmenu.add_command(label="Paste", command=self.paste)
    editmenu.bind("<Enter>",
                  lambda event: self.on_menu_select(event, editmenu))
    self.editmenu = editmenu
    menubar.add_cascade(label="Edit", menu=editmenu)

    code = "toolscode"
    toolsmenu = tk.Menu(menubar,
                        tearoff=0,
                        fg="white",
                        bg="#281c2c",
                        bd=0,
                        relief="flat",
                        font=("Verdana, 12"))
    toolsmenu.add_command(label="Find", command=self.find)
    toolsmenu.add_command(label="Replace", command=self.replace)
    toolsmenu.bind("<Enter>",
                   lambda event: self.on_menu_select(event, editmenu))
    self.toolsmenu = toolsmenu
    menubar.add_cascade(label="Tools", menu=toolsmenu)

    code = "insert_code"
    insertmenu = tk.Menu(menubar,
                         tearoff=0,
                         fg="white",
                         bg="#281c2c",
                         bd=0,
                         relief="flat",
                         font=("Verdana, 12"))
    insertmenu.add_command(label="Functions",
                           command=self.show_function_options)
    insertmenu.add_command(label="Callbacks",
                           command=self.show_callback_options)
    insertmenu.add_command(label="Notify & End On's",
                           command=self.show_notifyendons_options)
    insertmenu.add_command(label="ZMusings",
                           command=self.show_zmusings_options)
    insertmenu.add_command(label="MPUsings",
                           command=self.show_mpusings_options)
    insertmenu.bind("<Enter>",
                    lambda event: self.on_menu_select(event, editmenu))
    self.insertmenu = insertmenu
    menubar.add_cascade(label="Insert", menu=insertmenu)

    # Add zoom in and zoom out options
    zoom_menu = tk.Menu(menubar,
                        tearoff=0,
                        fg="white",
                        bg="#281c2c",
                        bd=0,
                        relief="flat",
                        font=("Verdana, 12"))
    zoom_menu.add_command(label="Zoom In", command=self.increase_scaling)
    zoom_menu.add_command(label="Zoom Out", command=self.decrease_scaling)
    zoom_menu.bind("<Enter>",
                   lambda event: self.on_menu_select(event, zoom_menu))
    zoom_menu.add_separator()
    # Add zoom options with the same function but different zoom values
    zoom_values = [75, 100, 150, 200, 250]
    for zoom in zoom_values:
      zoom_menu.add_command(
          label=f"Zoom {zoom}%",
          command=lambda zoom_value=zoom: self.set_zoom(zoom_value))
    self.zoom_menu = zoom_menu
    menubar.add_cascade(label="Zoom", menu=zoom_menu)

    # Add an About menu option and API list option
    code = "settings_menu"
    settingsmenu = tk.Menu(menubar,
                           tearoff=0,
                           fg="white",
                           bg="#281c2c",
                           bd=0,
                           relief="flat",
                           font=("Verdana, 12"))

    settingsmenu.add_command(
        label="API List",
        command=self.confirm_and_load_api_list)  # API List option

    settingsmenu.add_command(label="About", command=self.show_about_page)
    settingsmenu.add_command(label="Syntax color settings",
                             command=self.set_color_syntax)
    settingsmenu.add_command(label="Window color settings",
                             command=self.set_window_color)
    settingsmenu.bind("<Enter>",
                      lambda event: self.on_menu_select(event, editmenu))
    self.settingsmenu = settingsmenu
    menubar.add_cascade(label="Settings", menu=settingsmenu)

    master.config(menu=menubar)

    # Configure layout for the main window using pack
    master.pack_propagate(
        False)  # Prevent the window from resizing based on widgets inside it
    master.geometry("800x600")  # Set the default window size

    treestyle = ttk.Style()
    treestyle.theme_use('default')
    treestyle.configure("Treeview",
                        background="#281c2c",
                        foreground="white",
                        fieldbackground="#281c2c",
                        borderwidth=0)
    treestyle.map('Treeview',
                  background=[('selected', "white")],
                  foreground=[('selected', "#281c2c")])

    self.treestyle = treestyle
    root.bind("<<TreeviewSelect>>", lambda event: root.focus_set())

    # Create a parent frame to hold both the sidebar and the text frame
    self.container_frame = ctk.CTkFrame(self.master, bg_color="#281c2c")
    self.container_frame.pack(fill=tk.BOTH, expand=True)

    self.sidebar_main_frame = ctk.CTkFrame(self.container_frame,
                                           bg_color="#281c2c")
    self.sidebar_main_frame.pack(side="left", fill="y", padx=0, pady=0)

    # Define the option menu and set the command function
    values = [
        "New File", "New Folder", "Open Selected External",
        "Duplicate Selected Item", "Delete Selected Item"
    ]
    optionbox_var = ctk.StringVar(value="Library options")

    self.sidebar_bottom_menu = ctk.CTkOptionMenu(
        self.sidebar_main_frame,
        values=values,
        variable=optionbox_var,
        command=self.on_option_selected,  # Set the command to the function
        fg_color="#281c2c",
        button_color="#281c2c",
        text_color="white")
    self.sidebar_bottom_menu.pack(side="bottom", fill="x")

    # Sidebar frame creation
    self.sidebar = ctk.CTkFrame(self.sidebar_main_frame,
                                bg_color="#281c2c")  # Sidebar with fixed width
    self.sidebar.pack(side="left", fill="y", padx=0, pady=0,
                      ipadx=0)  # Sidebar takes full height

    self.sidebar_logo_frame = ctk.CTkFrame(self.sidebar, fg_color="#281c2c")
    self.sidebar_logo_frame.pack(side="top", fill="both", padx=0, pady=0)

    self.sidebar_logo_frame.grid_columnconfigure(0, weight=1, uniform="button")
    self.sidebar_logo_frame.grid_columnconfigure(1, weight=1, uniform="button")

    self.sidebar_logo = ctk.CTkLabel(
        self.sidebar_logo_frame,
        font=('Verdana', 10, "bold"),
        fg_color="#281c2c",
    )
    self.sidebar_logo.grid(column=0, row=0)
    self.sidebar_logo.configure(text="File Library")

    self.sidebar_logo_button = ctk.CTkButton(self.sidebar_logo_frame,
                                             command=self.go_back,
                                             width=10,
                                             text="Go Back",
                                             fg_color="#262335",
                                             border_width=3)
    self.sidebar_logo_button.grid(column=1, row=0)

    # Create a Treeview widget to display the folder structure
    self.tree = ttk.Treeview(self.sidebar, show="tree")
    self.tree.column("#0", anchor="center", stretch=True, width=160)
    self.tree.pack(side="left", fill="y", expand=True, ipadx=0, ipady=0)

    # Add a scrollbar to the Treeview
    scrollbar = ctk.CTkScrollbar(self.sidebar,
                                 orientation="vertical",
                                 command=self.tree.yview,
                                 fg_color="#281c2c")
    scrollbar.pack(side="right", fill="y")
    self.treescrollbar = scrollbar
    self.tree.configure(yscrollcommand=scrollbar.set)

    # Add a root node
    self.tree.heading("#0", text="Folders", anchor="w")
    self.tree.bind("<Double-1>",
                   self.on_item_double_click)  # Bind double click

    # Populate the treeview with folders starting from the home directory
    self.populate_tree()

    # Create a text frame for the main content
    self.text_frame = ctk.CTkFrame(self.container_frame,
                                   bg_color="#281c2c",
                                   fg_color="black",
                                   border_width=0)
    self.text_frame.pack(fill=tk.BOTH, expand=True, padx=0, pady=0)

    # Scrollable Text Widget (replace CTkTextbox with ScrollText)
    self.scroll_text = ScrollText(self.text_frame)
    self.scroll_text.pack(
        fill=tk.BOTH, expand=True)  # Expand both vertically and horizontally

    # Create the status bar with additional information (Line count, Char count)
    self.status_bar_frame = tk.Frame(master, bg="#281c2c")
    self.status_bar_frame.pack(fill=tk.X, side=tk.BOTTOM)

    # Line count label
    self.line_count_label = ctk.CTkLabel(
        self.status_bar_frame,
        text="Lines: 0",
        fg_color="#281c2c",
        #fg="white",
        padx=10)
    self.line_count_label.pack(side=tk.LEFT)

    # Spacer label
    self.spacer_label = ctk.CTkLabel(
        self.status_bar_frame,
        text=" ",
        fg_color="grey",
        #fg="white",
        width=1)
    self.spacer_label.pack(side=tk.LEFT)

    # Character count label
    self.char_count_label = ctk.CTkLabel(
        self.status_bar_frame,
        text="Chars: 0",
        fg_color="#281c2c",
        #fg="white",
        padx=10)
    self.char_count_label.pack(side=tk.LEFT)

    # Spacer label for some space before next element
    self.spacer_label2 = ctk.CTkLabel(
        self.status_bar_frame,
        text=" ",
        fg_color="grey",
        #fg="white",
        width=1)
    self.spacer_label2.pack(side=tk.LEFT)

    # Scaling Label
    self.scale_label = ctk.CTkLabel(
        self.status_bar_frame,
        text="100%",
        fg_color="#281c2c",
        #fg="white",
        padx=10)
    self.scale_label.pack(side=tk.RIGHT)
    # Current status (Ready)
    self.status_label = ctk.CTkLabel(
        self.status_bar_frame,
        text="Ready",
        #bg_color="#",
        fg_color="#281c2c",
        padx=10)
    self.status_label.pack(side=tk.RIGHT)

    # Bind to Ctrl+ and Ctrl- for scaling the window and widgets
    self.master.bind("<Control-plus>", self.increase_scaling)
    self.master.bind("<Control-minus>", self.decrease_scaling)

    # Periodically update line and character count
    self.update_status_bar()

    # File Operations
    self.filename = None

    # Bind click event to close menu when clicked outside
    self.master.bind("<Button-1>", self.close_menu_on_click)

    # Event binding to close all menus on click or type inside the text box
    self.scroll_text.text.bind("<Button-1>", self.close_menus_on_click_or_type)
    self.scroll_text.text.bind("<Key>", self.close_menus_on_click_or_type)

    # Bind Copy, Cut, and Paste commands
    self.scroll_text.text.bind("<Control-c>", self.copy)  # Ctrl + C for copy
    self.scroll_text.text.bind("<Control-x>", self.cut)  # Ctrl + X for cut
    self.scroll_text.text.bind("<Control-v>", self.paste)  # Ctrl + V for paste

    # Define the table of options for each category
    self.menu_options = {
        "function_options": [
            ("Empty Function",
             'function {func_name}()\n{\n\tlevel endon( "game_over" );\n}\n'),
            ("Trigger Use Function",
             'function {func_name}()\n{\n\ttrig = GetEnt("{trig_input}", "targetname");\n\ttrig SetCursorHint("HINT_NOICON");\n\ttrig SetHintString("{HINT_STRING}");\n\n\ttrig waittill("trigger", player);\n\n\tlevel notify( "{level_notify_input}", {level_notify_message} );\n}'
             ),
            #("Trigger Function", "function {func_name}()\n{\n    trig = GetEnt("\n}\n"),
            ("List Function",
             "function {func_name}()\n{\n    // Create a list here\n}\n"),
            ("Dictionary Function",
             "function {func_name}()\n{\n    // Create a dictionary here\n}\n")
        ],
        "callback_options":
        [("On Spawned Event Callback",
          'callback::on_spawned(&{callback_name});\\//function {callback_name}()\n{\n\tself = player\n}\n'
          ),
         ("On Connect Event Callback",
          "callback::on_spawned(&{callback_name});\\//function {callback_name}()\n{\n\tself = player\n}\n"
          )],
        "notifyendons_options":
        [("Empty Notify & End On's",
          'self notify("{notify_endon}");\n\tself endon("{notify_endon}");'),
         ("Print Notify & End On's",
          "function {notify_end_name}()\n{\n    printf('Notify & End On's triggered!');\n}\n"
          )],
        "zmusings_options":
        [("Empty ZMusings",
          "function {zmusings_name}()\n{\n    // ZMusings code here\n}\n"),
         ("Print ZMusings",
          "function {zmusings_name}()\n{\n    printf('ZMusings triggered!');\n}\n"
          )],
        "mpusings_options":
        [("Empty MPUsings",
          "function {mpusings_name}()\n{\n    // MPUsings code here\n}\n"),
         ("Print MPUsings",
          "function {mpusings_name}()\n{\n    printf('MPUsings triggered!');\n}\n"
          )]
    }

    self.update_line_numbers()
    # Synchronize scrolling between text area and line numbers
    self.scroll_text.text.configure(yscrollcommand=self.__scrollBoth)

  def decrease_scaling(self, arg=None):
    global count
    current_scaling = count
    new_scaling = current_scaling - 0.5 if current_scaling > 1 else 0.25
    if new_scaling >= 0.5:
      count = new_scaling
      ctk.set_widget_scaling(new_scaling)
      percentage = self.scale_to_percentage(count)
      self.scale_label.configure(text=f"{percentage}%")
    else:
      count = 0.75
      ctk.set_widget_scaling(0.75)
      percentage = self.scale_to_percentage(count)
      self.scale_label.configure(text="75%")
      self.status_label.configure(
          text="The zoom level is already set to the lowest value")
      root.after(2000, lambda: self.status_label.configure(text="Ready"))

  def increase_scaling(self, arg=None):
    global count
    current_scaling = count
    new_scaling = current_scaling + 0.5
    if new_scaling == 1.25:
      new_scaling = current_scaling + 0.25
      ctk.set_widget_scaling(new_scaling)
      percentage = self.scale_to_percentage(new_scaling)
      self.scale_label.configure(text=f"{percentage}%")
    elif new_scaling <= 2.5:
      count = new_scaling
      ctk.set_widget_scaling(new_scaling)
      percentage = self.scale_to_percentage(count)
      self.scale_label.configure(text=f"{percentage}%")
    else:
      count = 2.5
      ctk.set_widget_scaling(2.5)
      percentage = self.scale_to_percentage(count)
      self.scale_label.configure(text="250%")
      self.status_label.configure(
          text="The zoom level is already set to the highest value")
      root.after(2000, lambda: self.status_label.configure(text="Ready"))

  def set_zoom(self, zoom_value):
    global count
    value = count * 100
    if value == zoom_value:
      count = count
      ctk.set_widget_scaling(count)
      percentage = self.scale_to_percentage(count)
      self.scale_label.configure(text=f"{percentage}%")
      self.status_label.configure(
          text="The zoom level is already set to the desired value.")
      root.after(2000, lambda: self.status_label.configure(text="Ready"))
    else:
      currentscaling = count
      new_scaling = zoom_value / 100
      count = new_scaling
      ctk.set_widget_scaling(new_scaling)
      percentage = self.scale_to_percentage(count)
      self.scale_label.configure(text=f"{percentage}%")
      self.status_label.configure(
          text="The zoom level has been set to the desired value.")
      root.after(2000, lambda: self.status_label.configure(text="Ready"))

  def scale_to_percentage(self, scaling):
    """Maps scaling value to a percentage."""
    return int(scaling * 100)

  def extract_number_from_string(self, input_string):
    """Extracts the first number from a string and returns it as a float."""
    match = re.search(r'[-+]?\d*\.\d+|\d+', input_string)
    if match:
      return float(match.group())
    return None

  def update_scaling(self):
    """Apply the new font size to all widgets in the window"""
    # Update the font of the SyntaxHighlighter widget
    self.scroll_text.text.configure(
        font=("Verdana", self.scroll_text.text.syntax.font_size))

  def populate_tree(self, parent=""):
    """Populate the tree with folders and files."""
    # Determine the path based on the parent
    if parent == "":
      path = os.path.expanduser(
          "~/SkeletalSociableCores")  # Default start path
    else:
      path = parent
    print(f"Populating tree with: {path}")

    # Clear the tree before populating
    for child in self.tree.get_children():
      self.tree.delete(child)
    self.workingpath = path
    print(self.workingpath)
    try:
      if os.path.isdir(path):
        for item in os.listdir(path):
          item_path = os.path.join(path, item)
          isdir = os.path.isdir(item_path)
          if isdir:

            self.tree.insert("",
                             "end",
                             text=f"{item}.folder" + u"\u00AC",
                             values=(item_path, ))
          else:
            # Insert files without a suffix
            self.tree.insert("", "end", text=item, values=(item_path, ))
    except PermissionError:
      print(f"Permission denied: {path}")  # Handle inaccessible directories

  def on_item_double_click(self, event):
    """Handle the double-click event on a folder or file."""
    selected_item = self.tree.selection()
    if not selected_item:
      return

    selected_item = selected_item[0]
    item_text = self.tree.item(selected_item)["text"]

    # Check if the item is a folder and expand it if necessary
    if self.tree.get_children(selected_item):
      return  # Folder is already expanded

    # Check if the item is a "loading" dummy item, indicating it's a folder
    if item_text.endswith(".folder" + u"\u00AC"):
      # Remove the "loading" dummy item and populate the folder's contents
      folder_path = os.path.join(os.path.expanduser("~/SkeletalSociableCores"),
                                 item_text.removesuffix(".folder" + u"\u00AC"))
      folder_path = folder_path + "/"
      self.populate_tree(parent=folder_path)

    # If it's a file, open it in a Text widget instead of the default opener
    else:
      file_path = os.path.join(os.path.expanduser("~/SkeletalSociableCores"),
                               item_text)
      if os.path.isfile(file_path):
        self.open_file(file_path)

  # Create a toggle button to show/hide the sidebar
  def toggle_sidebar(self, event=None):

    if self.sidebar.winfo_ismapped(
    ):  # Check if the sidebar is currently visible
      self.sidebar_main_frame.pack_forget()  # Hide the sidebar
    else:
      self.text_frame.pack_forget()
      self.sidebar_main_frame.pack(side="left",
                                   fill="y",
                                   padx=0,
                                   pady=0,
                                   ipadx=0)
      self.text_frame.pack(fill=tk.BOTH, expand=True, padx=0, pady=0)

  def on_menu_select(self, event, menu):
    """ Close all other menus when a new menu is opened. """
    # Close all active menus before opening the new one
    self.close_all_active_menus()

    # Track this menu as an active menu
    self.active_menus.append(menu)

  def go_back(self):
    """Navigate to the parent directory."""
    # Get the current path
    if hasattr(self, "current_path") and self.current_path:
      path = self.current_path
    else:
      path = os.path.expanduser(
          "~/SkeletalSociableCores")  # Default start path

    # Get the parent directory
    parent_path = os.path.dirname(path.rstrip(os.path.sep))

    # Prevent navigating above the default start directory
    default_path = os.path.expanduser("~/SkeletalSociableCores")
    if os.path.commonpath([parent_path, default_path]) != default_path:
      parent_path = default_path

    # Update the tree with the parent directory's contents
    self.populate_tree(parent=parent_path)

    # Update the current path
    self.current_path = parent_path

  def new_file(self):
    self.scroll_text.text.delete("1.0", tk.END)
    self.filename = None
    self.status_label.configure(text="New File")
    self.update_line_numbers()

  def open_file(self, file=None):
    if file is None:
      self.filename = filedialog.askopenfilename(defaultextension=".gsc",
                                                 filetypes=[
                                                     ("GSC Files", "*.gsc"),
                                                     ("CSC Files", "*.csc"),
                                                     ("All Files", "*.*")
                                                 ])
    else:
      self.filename = file
    print(self.filename)
    if self.filename:
      try:
        with open(self.filename, "r") as f:
          fileread = f.read()
          self.scroll_text.delete("1.0", tk.END)
          self.scroll_text.insert(tk.END, fileread)
        self.status_label.configure(text=f"Opened: {self.filename}")
        self.update_line_numbers()
        self.scroll_text.text.syntax.apply_syntax_highlighting(fileread)
        root.after(2000, lambda: self.status_label.configure(text="Ready"))
      except FileNotFoundError:
        messagebox.showerror("Error", f"File not found: {self.filename}")

  def save_file(self):
    if self.filename:
      try:
        with open(self.filename, "w") as f:
          f.write(self.scroll_text.text.get("1.0", tk.END))
        self.status_label.configure(text=f"Saved: {self.filename}")
        root.after(2000, lambda: self.status_label.configure(text="Ready"))
      except Exception as e:
        messagebox.showerror("Error", f"Could not save file: {e}")
    else:
      self.save_as_file()

  def save_as_file(self):
    self.filename = filedialog.asksaveasfilename(defaultextension=".txt",
                                                 filetypes=[
                                                     ("Text Files", "*.txt"),
                                                     ("All Files", "*.*")
                                                 ])
    if self.filename:
      try:
        with open(self.filename, "w") as f:
          f.write(self.scroll_text.get("1.0", tk.END))
        self.status_label.configure(text=f"Saved As: {self.filename}")
      except Exception as e:
        messagebox.showerror("Error", f"Could not save file: {e}")

  # Edit Operation
  def undo(self):
    self.scroll_text.text.edit_undo()

  def redo(self):
    self.scroll_text.redo()

  def copy(self, event=None):
    """Copy the selected text to the clipboard."""
    try:
      # Get the selected text from CTkTextbox
      selected_text = self.scroll_text.get(tk.SEL_FIRST, tk.SEL_LAST)
      # Clear and append the selected text to the clipboard (using root)
      self.master.clipboard_clear()  # Access the root window's clipboard
      self.master.clipboard_append(selected_text)
    except tk.TclError:
      # Handle the case where no text is selected
      print("No text selected to copy.")

  def cut(self, event=None):
    """Cut the selected text to the clipboard."""
    try:
      # Get the selected text from CTkTextbox
      selected_text = self.text.get(tk.SEL_FIRST, tk.SEL_LAST)
      # Clear and append the selected text to the clipboard
      self.master.clipboard_clear()  # Access the root window's clipboard
      self.master.clipboard_append(selected_text)
      # Delete the selected text from the widget
      self.scroll_text.delete(tk.SEL_FIRST, tk.SEL_LAST)
    except tk.TclError:
      # Handle the case where no text is selected
      print("No text selected to cut.")

  def paste(self, event=None):
    """Paste the clipboard content into the text widget."""
    try:
      clipboard_content = self.master.clipboard_get(
      )  # Access the root window's clipboard
      # Insert the clipboard content at the current cursor position
      self.scroll_text.insert(tk.INSERT, clipboard_content)
    except tk.TclError:
      # Handle the case where clipboard is empty or inaccessible
      print("Clipboard is empty or could not be accessed.")

  # Tools Operations
  def find(self):
    # Implement find functionality here
    pass

  def replace(self):
    # Implement replace functionality here
    pass

  def show_menu_options(self, category, event=None):
    """ Show the menu options for the given category (including submenus). """
    # Close all previously active menus
    self.close_all_active_menus()

    # Create the new menu
    options_menu = tk.Menu(self.master, tearoff=0)

    # Add the menu items for the given category
    for label, code in self.menu_options[category]:
      options_menu.add_command(
          label=label,
          command=lambda code=code: self.prompt_for_input_and_insert(code))

    # Position the menu based on mouse click position
    options_menu.post(self.master.winfo_pointerx(),
                      self.master.winfo_pointery())

    # Track this menu as an active menu
    self.active_menus.append(options_menu)

  def update_status_bar(self):
    """ Update the status bar with the line count and character count. """
    # Get the current text in the text widget
    text_content = self.scroll_text.get("1.0", "end-1c")

    # Count the number of lines and characters
    line_count = len(text_content.splitlines())
    char_count = len(text_content)

    # Update the labels in the status bar
    self.line_count_label.configure(text=f"Lines: {line_count}")
    self.char_count_label.configure(text=f"Chars: {char_count}")

    # Call this method again after 5000 ms (5 seconds)
    self.master.after(2500, self.update_status_bar)

  def prompt_for_input_and_insert(self, code):
    # This function will now support multiple placeholders dynamically
    placeholders = {}
    user_inputs = {}

    # Check if the special placeholder '\\//' exists in the code
    if '\\//' in code:
      # Split code at the '\\//' and treat everything after it as end content
      pre_placeholder_code, post_placeholder_code = code.split('\\//', 1)
    else:
      pre_placeholder_code, post_placeholder_code = code, ""

    # Find all placeholders in the pre-placeholder code using regular expressions
    matches = re.findall(r"\{(.*?)\}", pre_placeholder_code)

    # For each unique placeholder, ask the user for input (if not already provided)
    for match in set(
        matches):  # Use set to ensure each placeholder is only asked once
      if match not in user_inputs:
        user_input = simpledialog.askstring(
            "Input", f"Please enter a value for {match}:")
        if user_input:
          user_inputs[match] = user_input
        else:
          user_inputs[match] = match  # If no input, use the placeholder as is
      else:
        # If the input for this placeholder is already stored, use it
        pass

    # Replace placeholders in the pre-placeholder code with the user's input
    for placeholder, user_input in user_inputs.items():
      pre_placeholder_code = pre_placeholder_code.replace(
          f"{{{placeholder}}}", user_input)

    # Add a newline at the end of the pre-placeholder code to ensure the insertion appears correctly
    pre_placeholder_code = pre_placeholder_code + "\n"

    # Insert the modified pre-placeholder code at the cursor position
    self.scroll_text.insert(tk.INSERT, pre_placeholder_code)

    # Insert the post-placeholder code at the end of the text area
    if post_placeholder_code:
      # Replace any placeholders in the post-placeholder code too
      for placeholder, user_input in user_inputs.items():
        post_placeholder_code = post_placeholder_code.replace(
            f"{{{placeholder}}}", user_input)
      # Insert the post-placeholder code at the end
      self.scroll_text.insert(tk.END, post_placeholder_code)

    self.update_line_numbers()

    self.scroll_text.text.edit_undo()  # Add to undo queue
    self.scroll_text.text.edit_redo()  # Add to redo queue

  def show_function_options(self, event=None):
    self.show_menu_options("function_options", event)

  def show_callback_options(self, event=None):
    self.show_menu_options("callback_options", event)

  def show_notifyendons_options(self, event=None):
    self.show_menu_options("notifyendons_options", event)

  def show_zmusings_options(self, event=None):
    self.show_menu_options("zmusings_options", event)

  def show_mpusings_options(self, event=None):
    self.show_menu_options("mpusings_options", event)

  def close_all_active_menus(self):
    """ Close all active menus (main and submenus). """
    while self.active_menus:
      menu = self.active_menus.pop()
      menu.unpost()  # Close the menu

  def close_all_active_menus_on_click(self, event):
    """ Close all active menus when clicking on the menu bar. """
    # Only close if the click is outside the currently open menu
    if not self.master.winfo_containing(event.x_root, event.y_root):
      self.close_all_active_menus()

  def close_menu_on_click(self, event):
    """ Close all active menus when clicking on the menu bar. """
    # Only close if the click is outside the currently open menu
    if not self.master.winfo_containing(event.x_root, event.y_root):
      self.close_all_active_menus()

  def close_menus_on_click_or_type(self, event=None):
    """ Close all active menus when clicking or typing in the text area. """
    self.close_all_active_menus()  # Close all menus

  def show_about_page(self):
    about_window = tk.Toplevel(self.master)
    about_window.title("About")

    # Centering the text and adding an image
    about_frame = ctk.CTkFrame(about_window,
                               corner_radius=0,
                               fg_color="#e4dcca")
    about_frame.pack(padx=0, pady=0, fill=tk.BOTH, expand=True)

    # Load and display the image
    try:
      #logo_image = PhotoImage(
         # file="logo.png")  # Replace with the path to your image
      logo_label = tk.Label(about_frame, image=logo_image)
      logo_label.image = logo_image  # Keep reference to prevent garbage collection
      logo_label.pack(pady=10)
    except Exception as e:
      print("Image not loaded:", e)

    # About text centered
    about_text = (
        "GSCript Text Editor\n\n"
        "This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License\n"
        "as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n\n"
        "This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
        "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\n"
        "You should have received a copy of the GNU General Public License along with this program.\n"
        "If not, see <http://www.gnu.org/licenses/>.\n\n\n"
        "Created by Bigmanting\n"
        "This is a simple text editor created using Tkinter.\n"
        "Copyright (C) 2025 Jay <Redacted>")

    info_label = ctk.CTkLabel(about_frame,
                              text=about_text,
                              justify=tk.CENTER,
                              bg_color="#e4dcca",
                              text_color="black")
    info_label.pack(padx=10, pady=10)

  def confirm_and_load_api_list(self):
    # Ask for confirmation before opening the API list
    response = messagebox.askyesno(
        "Open API List", "Do you want to open the API list from the web?")

    if response:
      self.load_api_list()

  def load_api_list(self):
    # Open a web browser with the API list
    api_url = "https://www.example.com/api"  # Replace with the actual URL of the API list
    webbrowser.open(
        api_url)  # This will open the URL in the default web browser

  def update_line_numbers(self, event=None):
    self.scroll_text.redraw()

  def __scrollBoth(self, *args):
    # Synchronize the scrolling of the text area and the line numbers
    position = self.scroll_text.text.yview()[
        0]  # Get the position of the text area scroll
    self.scroll_text.numberLines.yview_moveto(
        position)  # Sync line numbers' scrollbar with the text area

    # Update the line number display
    self.scroll_text.numberLines.redraw()

  def set_color_syntax(self):
    """Opens a window to set syntax highlighting colors."""

    def update_color(color, tag):
      """Updates the syntax highlighting color for the given tag."""
      self.scroll_text.text.tag_config(tag, foreground=color)

    def select_color(tag):
      """Opens a color picker for the given tag and updates the color."""

      def on_color_selected(color):
        """Callback for when a color is selected in the color picker."""
        update_color(color, tag)
        self.status_label.configure(text=f"Selected: {color} for {tag}")
        # Update the label in the corresponding frame
        if tag == "keyword":
          keyword_label.configure(text=f"Selected: {color}")
        elif tag == "string":
          string_label.configure(text=f"Selected: {color}")
        elif tag == "comment":
          comment_label.configure(text=f"Selected: {color}")
        elif tag == "variable":
          variable_label.configure(text=f"Selected: {color}")
        elif tag == "red":
          red_label.configure(text=f"Selected: {color}")

      color_picker = colorchooser.askcolor(title=f"Select {tag} Color")
      if color_picker[1]:
        on_color_selected(color_picker[1])

    color_window = ctk.CTk()
    color_window.geometry("500x350")  # Adjust size as needed
    color_window.title("Syntax Highlighting Colors")
    color_window.resizable(False, False)

    # Add padding for the top
    ctk.CTkFrame(color_window, height=8).pack(pady=10)

    # Get current colors
    keyword_color = self.scroll_text.text.tag_cget("keyword", "foreground")
    string_color = self.scroll_text.text.tag_cget("string", "foreground")
    comment_color = self.scroll_text.text.tag_cget("comment", "foreground")
    variable_color = self.scroll_text.text.tag_cget("variable", "foreground")
    red_color = self.scroll_text.text.tag_cget("red", "foreground")

    # Define frames and labels
    keyword_frame = ctk.CTkFrame(color_window)
    keyword_frame.pack(pady=10)
    ctk.CTkLabel(keyword_frame, text="Keyword Color:").pack(side="left",
                                                            padx=10,
                                                            pady=5)
    keyword_label = ctk.CTkLabel(keyword_frame, text=f"{keyword_color}")
    keyword_label.pack(side="left")
    ctk.CTkButton(keyword_frame,
                  fg_color=keyword_color,
                  text="Select",
                  command=lambda: select_color("keyword")).pack(side="left",
                                                                padx=10)

    string_frame = ctk.CTkFrame(color_window)
    string_frame.pack(pady=10)
    ctk.CTkLabel(string_frame, text="String Color:").pack(side="left",
                                                          padx=10,
                                                          pady=5)
    string_label = ctk.CTkLabel(string_frame, text=f"{string_color}")
    string_label.pack(side="left")
    ctk.CTkButton(string_frame,
                  fg_color=string_color,
                  text="Select",
                  command=lambda: select_color("string")).pack(side="left",
                                                               padx=10)

    comment_frame = ctk.CTkFrame(color_window)
    comment_frame.pack(pady=10)
    ctk.CTkLabel(comment_frame, text="Comment Color:").pack(side="left",
                                                            padx=10,
                                                            pady=5)
    comment_label = ctk.CTkLabel(comment_frame, text=f"{comment_color}")
    comment_label.pack(side="left")
    ctk.CTkButton(comment_frame,
                  fg_color=comment_color,
                  text="Select",
                  command=lambda: select_color("comment")).pack(side="left",
                                                                padx=10)

    variable_frame = ctk.CTkFrame(color_window)
    variable_frame.pack(pady=10)
    ctk.CTkLabel(variable_frame, text="Variable Color:").pack(side="left",
                                                              padx=10,
                                                              pady=5)
    variable_label = ctk.CTkLabel(variable_frame, text=f"{variable_color}")
    variable_label.pack(side="left")
    ctk.CTkButton(variable_frame,
                  fg_color=variable_color,
                  text="Select",
                  command=lambda: select_color("variable")).pack(side="left",
                                                                 padx=10)

    red_frame = ctk.CTkFrame(color_window)
    red_frame.pack(pady=10)
    ctk.CTkLabel(red_frame, text="Red Color:").pack(side="left",
                                                    padx=10,
                                                    pady=5)
    red_label = ctk.CTkLabel(red_frame, text=f"{red_color}")
    red_label.pack(side="left")
    ctk.CTkButton(red_frame,
                  fg_color=red_color,
                  text="Select",
                  command=lambda: select_color("red")).pack(side="left",
                                                            padx=10)

  def set_window_color(self):
    """Opens a window to select three colors and applies them to window frames."""

    def select_color(frame_key, label, color_button):
      overwrite_table = {
          "frame1": "#282c2c",
          "frame2": "#262335",
          "frame3": "#FFFFFF"
      }
      """Opens a color picker for the given frame and updates the label text."""
      color_picker = colorchooser.askcolor(
          title=f"Select Color for {frame_key}")
      if color_picker[1]:
        self.selected_colors[frame_key] = color_picker[1]
        label.configure(text=f"Selected: {color_picker[1]}")
        color_button.configure(fg_color=color_picker[1])

    def reset_colors():
      apply_colors(overwrite=True)
      self.status_label.configure(text="Colors reset.")
      root.after(2000, lambda: self.status_label.configure(text="Ready"))

    def apply_colors(overwrite=None):
      self.selected_colors["inverted_font"] = self.invert_hex_color(
          hex_color=self.selected_colors["frame3"])
      if overwrite:
        self.selected_colors["frame1"] = "#262335"
        self.selected_colors["frame2"] = "#281c2c"
        self.selected_colors["frame3"] = "#FFFFFF"

      # Example application logic:
      self.filemenu.configure(bg=self.selected_colors["frame1"],
                              fg=self.selected_colors["frame3"])
      self.editmenu.configure(bg=self.selected_colors["frame1"],
                              fg=self.selected_colors["frame3"])
      self.toolsmenu.configure(bg=self.selected_colors["frame1"],
                               fg=self.selected_colors["frame3"])
      self.insertmenu.configure(bg=self.selected_colors["frame1"],
                                fg=self.selected_colors["frame3"])
      self.zoom_menu.configure(bg=self.selected_colors["frame1"],
                               fg=self.selected_colors["frame3"])
      self.settingsmenu.configure(bg=self.selected_colors["frame1"],
                                  fg=self.selected_colors["frame3"])
      self.scroll_text.text.syntax.configure(
          fg_color=self.selected_colors["frame1"],
          text_color=self.selected_colors["frame3"])
      self.scroll_text.numberLines.configure(bg=self.selected_colors["frame2"])
      self.scroll_text.numberLines.redraw(color=self.selected_colors["frame3"])
      self.status_label.configure(fg_color=self.selected_colors["frame2"],
                                  text_color=self.selected_colors["frame3"])
      self.scale_label.configure(fg_color=self.selected_colors["frame2"],
                                 text_color=self.selected_colors["frame3"])
      self.char_count_label.configure(
          fg_color=self.selected_colors["frame2"],
          text_color=self.selected_colors["frame3"])
      self.line_count_label.configure(
          fg_color=self.selected_colors["frame2"],
          text_color=self.selected_colors["frame3"])
      self.status_bar_frame.configure(bg=self.selected_colors["frame2"])
      self.menubar.configure(
          bg=self.selected_colors["frame2"],
          fg=self.selected_colors["frame3"],
          activeforeground=self.selected_colors["inverted_font"],
          activebackground=self.selected_colors["frame3"])
      self.sidebar_logo.configure(fg_color=self.selected_colors["frame2"],
                                  text_color=self.selected_colors["frame3"])
      self.sidebar_bottom_menu.configure(
          fg_color=self.selected_colors["frame2"],
          button_color=self.selected_colors["frame2"],
          text_color=self.selected_colors["frame3"])
      self.sidebar_main_frame.configure(
          bg_color=self.selected_colors["frame2"],
          fg_color=self.selected_colors["frame2"])
      self.sidebar_logo_frame.configure(
          fg_color=self.selected_colors["frame2"])
      self.treescrollbar.configure(fg_color=self.selected_colors["frame2"])
      self.treestyle.configure("Treeview",
                               background=self.selected_colors["frame2"],
                               foreground=self.selected_colors["frame3"],
                               fieldbackground=self.selected_colors["frame2"])
      color_window.destroy()

    # Create the popup window
    color_window = ctk.CTkToplevel(
    )  # Use CTkToplevel instead of CTk to keep parent open
    color_window.geometry("400x300")
    color_window.title("Set Frame Colors")
    color_window.resizable(False, False)

    # Helper to create frame color selectors
    def create_color_selector(frame_key, frame_text):
      frame = ctk.CTkFrame(color_window)
      frame.pack(pady=10, padx=10, fill="x")
      ctk.CTkLabel(frame, text=f"{frame_text} Color:").pack(side="left",
                                                            padx=10)
      color_label = ctk.CTkLabel(frame,
                                 text=f"{self.selected_colors[frame_key]}")
      color_label.pack(side="left", padx=10)
      color_button = ctk.CTkButton(
          frame,
          text="Select",
          fg_color=self.selected_colors[frame_key],
          text_color="#FFFFFF"
          if self.selected_colors[frame_key] != "#FFFFFF" else "black",
          command=lambda: select_color(frame_key, color_label, color_button),
      )
      color_button.pack(side="right", padx=10)

    # Create selectors for three frames
    create_color_selector("frame1", "Text BG")
    create_color_selector("frame2", "Menus")
    create_color_selector("frame3", "Font")

    button_frame = ctk.CTkFrame(color_window)
    button_frame.pack(pady=10, anchor="nw", fill="x")
    # Configure the grid to have two columns
    button_frame.grid_columnconfigure(0, weight=1, uniform="button")
    button_frame.grid_columnconfigure(1, weight=1, uniform="button")
    # Apply button
    ctk.CTkButton(button_frame, text="Apply",
                  command=apply_colors).grid(row=0,
                                             column=0,
                                             padx=10,
                                             sticky="ew")
    ctk.CTkButton(button_frame, text="Reset",
                  command=reset_colors).grid(row=0,
                                             column=1,
                                             padx=10,
                                             sticky="ew")

    color_window.grab_set()  # Ensure the popup window stays focused
    color_window.mainloop()

  def on_option_selected(self, selected_option):
    if selected_option == "New File":
      # Create a new file (you can specify a default name or ask for one)
      file_name = simpledialog.askstring("New File",
                                         "Enter the new file name:")
      if file_name:
        try:
          # Create the file in the current directory (or specify a path)
          with open(file_name, "w") as new_file:
            new_file.write("")  # Create an empty file
          messagebox.showinfo("Success",
                              f"File '{file_name}' created successfully.")
        except Exception as e:
          messagebox.showerror("Error", f"Failed to create file: {e}")

      self.populate_tree(parent=self.workingpath)

    elif selected_option == "New Folder":
      # Create a new folder (you can specify a default folder name or ask for one)
      folder_name = simpledialog.askstring("New Folder",
                                           "Enter the new folder name:")
      if folder_name:
        try:
          path = self.workingpath + "/" + folder_name
          print(path)
          os.makedirs(path, exist_ok=True)
          messagebox.showinfo(
              "Success",
              f"Folder '{folder_name}' created successfully in {self.workingpath}."
          )
        except Exception as e:
          messagebox.showerror("Error", f"Failed to create folder: {e}")

      self.populate_tree(parent=self.workingpath)
    elif selected_option == "Duplicate Selected Item":
      # Implement the logic to duplicate the selected item
      selected_item = self.tree.selection()
      if not selected_item:
        messagebox.showwarning("No Selection",
                               "Please select a file to duplicate")
        return

      selected_item = selected_item[0]
      item_text = self.tree.item(selected_item)["text"]
      item_path = os.path.join(os.path.expanduser("~/SkeletalSociableCores"),
                               item_text)
      print(item_text)
      if os.path.isdir(item_path):
        messagebox.showwarning("Folder Selected",
                               "Cannot duplicate folder/directory")
        return
      else:
        try:
          destination_path = os.path.join(
              os.path.expanduser("~/SkeletalSociableCores"),
              "Copy of " + item_text)
          shutil.copy(item_path, destination_path)
          messagebox.showinfo("Success",
                              f"File '{item_text}' duplicated successfully.")
        except Exception as e:
          messagebox.showerror(
              "Error", f"An error occurred while duplicating the file: {e}")

    elif selected_option == "Open Selected External":
      # Open the selected external file/folder
      selected_item = self.tree.selection()
      if not selected_item:
        messagebox.showwarning("No Selection",
                               "Please select a file or folder to open.")
        return

      selected_item = selected_item[0]
      item_text = self.tree.item(selected_item)["text"]
      item_path = os.path.join(os.path.expanduser("~/SkeletalSociableCores"),
                               item_text)  # Construct the full path

      if os.path.exists(item_path):  # Check if the item exists
        if os.path.isfile(item_path):
          # Open the file in the default application
          try:
            subprocess.run(["xdg-open", item_path], check=True)
            messagebox.showinfo("Action", f"Opening file: {item_text}")
          except subprocess.CalledProcessError as e:
            messagebox.showerror("Error", f"Failed to open file: {e}")
        elif os.path.isdir(item_path):
          # Open the folder in the default file explorer
          try:
            subprocess.run(["xdg-open", item_path], check=True)
            messagebox.showinfo("Action", f"Opening folder: {item_text}")
          except subprocess.CalledProcessError as e:
            messagebox.showerror("Error", f"Failed to open folder: {e}")
      else:
        messagebox.showwarning("Invalid Path",
                               "The selected file/folder does not exist.")
    elif selected_option == "Delete Selected Item":
      # Delete selected folder or file
      selected_item = self.tree.selection()
      if not selected_item:
        messagebox.showwarning("No Selection",
                               "Please select an item to delete.")
        return

      selected_item = selected_item[0]
      item_text = self.tree.item(selected_item)["text"]

      # Remove the ".folder\u00AC" suffix for folders
      if item_text.endswith(".folder" + u"\u00AC"):
        item_text = item_text.removesuffix(".folder" + u"\u00AC")

      # Build the full path
      item_path = os.path.join(os.path.expanduser(self.workingpath),
                               item_text)
      print(item_path)

      # Ask for confirmation before deleting
      confirmation = messagebox.askyesno(
          "Confirm Deletion",
          f"Are you sure you want to delete the item '{item_text}'? This action cannot be undone."
      )

      if confirmation:
        try:
          # Delete the folder or file
          if os.path.isdir(item_path):
            shutil.rmtree(item_path)  # Use shutil.rmtree for non-empty folders
            self.tree.delete(selected_item)  # Remove from the treeview
            messagebox.showinfo("Success",
                                f"Folder '{item_text}' deleted successfully.")
          elif os.path.isfile(item_path):
            os.remove(item_path)
            self.tree.delete(selected_item)
            messagebox.showinfo("Success",
                                f"File '{item_text}' deleted successfully.")
          else:
            messagebox.showerror("Error",
                                 f"The item '{item_text}' does not exist.")
        except Exception as e:
          messagebox.showerror("Error", f"Failed to delete item: {e}")

      # Refresh the treeview to reflect the changes
      self.populate_tree(parent=self.workingpath)

  # Method to refresh the Treeview by clearing and repopulating it
  def refresh_tree(self):
    # Clear the current items in the treeview
    for item in self.tree.get_children():
      self.tree.delete(item)

    # Repopulate the Treeview (you can define your logic here)
    self.populate_tree()

  def invert_hex_color(self, hex_color):
    """Inverts a given hex color."""
    # Remove the '#' if present
    hex_color = hex_color.lstrip('#')
    # Convert hex to RGB
    r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4],
                                           16), int(hex_color[4:6], 16)
    # Invert the RGB values
    inverted_r, inverted_g, inverted_b = 255 - r, 255 - g, 255 - b
    # Convert back to hex
    inverted_color = f"#{inverted_r:02X}{inverted_g:02X}{inverted_b:02X}"
    return inverted_color


root = tk.Tk()
editor = TextEditor(root)
root.mainloop()
